/* A Hercules IR transformation that cleans-up the IR generated by the frontend.
 * In particular, we do the following
 * - Eliminate phi nodes where all inputs are the same (here this means the same
 *   node in IR, we are not performing GVM, SCCP, or any similar optimization)
 * - Eliminate regions with only a single predecessor
 *
 * The first of these two pieces can be seen as the optimizations that the
 * SSA construction paper suggests, but we have to perform it as a separate
 * step because we cannot easily eliminate phi nodes once we have constructed
 * code that relies on them
 */
use std::collections::HashMap;
use hercules_ir::ir::*;
use hercules_ir::get_uses_mut;

pub fn clean_ir(module : &mut Module) {
    for func in module.functions.iter_mut() {
        // Keep a map of nodes that we need to replace, and what we need to
        // replace them with
        let mut replace_nodes : HashMap<usize, NodeID> = HashMap::new();

        // Iterate over the nodes of the function until convergence
        // In this loop, we look for phis and regions that can be eliminated,
        // mark them as gravestones, and add them to the replacement map.
        // For all other nodes, we see if any of their arguments are in the
        // replacement map and if so eliminate them
        let mut changed = true;
        while changed {
            changed = false;

            for (idx, node) in func.nodes.iter_mut().enumerate() {
                // Replace any nodes that this node uses that are in the replacement map
                for u in get_uses_mut(node).as_mut() {
                    let old_id = u.idx();
                    if let Some(replacement) = replace_nodes.get(&old_id) {
                        **u = *replacement;
                    }
                }

                // Then, check if this node can be removed
                if let Node::Phi { control : _, data } = node {
                    // For a phi, we can remove it if all of its data inputs are the same node or
                    // self-cycles
                    let mut unique = Some(data[0]);
                    for i in 1..data.len() {
                        // Ignore self-loops
                        if data[i].idx() != idx && Some(data[i]) != unique{
                            if unique.unwrap().idx() == idx {
                                unique = Some(data[i]);
                            } else {
                                unique = None; break;
                            }
                        }
                    }
                    if let Some(value) = unique {
                        changed = true;
                        replace_nodes.insert(idx, value);
                        *node = Node::Start; // mark node as removed
                    }
                } else if let Node::Region { preds } = node {
                    if preds.len() == 1 {
                        changed = true;
                        replace_nodes.insert(idx, preds[0]);
                        *node = Node::Start; // mark as dead
                    }
                }
            }
        }

        // Now, eliminate the gravestones
        // We don't need the map from old node IDs to new node IDs because we don't have any
        // auxilliary data structures at this point
        let _ = func.delete_gravestones();
    }
}
